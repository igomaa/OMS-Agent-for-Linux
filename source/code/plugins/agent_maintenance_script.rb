require 'openssl'
require 'fileutils'
require 'net/http'
require 'uri'
require 'optparse'

module MaintenanceModule

  class Maintenance
    require_relative 'oms_common'

    # Constants
    attr_reader :AGENT_USER, :string
    attr_reader :AGENT_GROUP, :string
    attr_reader :TOPOLOGY_REQ_SCRIPT, :string
    attr_reader :RUBY, :string
    # Passed in parameters
    attr_reader :omsadmin_conf_path
    attr_reader :cert_path
    attr_reader :key_path
    attr_reader :proxy_path
    attr_reader :os_info
    attr_reader :install_info
  
    def initialize(omsadmin_conf_path, cert_path, key_path, proxy_path, os_info, install_info)
      @AGENT_USER = "omsagent"
      @AGENT_GROUP = "omiusers"
      @TOPOLOGY_REQ_SCRIPT = "/opt/microsoft/omsagent/plugin/agent_topology_request_script.rb"
      @RUBY = "/opt/microsoft/omsagent/ruby/bin/ruby"
      @omsadmin_conf_path = omsadmin_conf_path
      @cert_path = cert_path
      @key_path = key_path
      @proxy_path = proxy_path
      @os_info = os_info
      @install_info = install_info
      # Config to be read from omsadmin.conf
      @WORKSPACE_ID = nil
      @AGENT_GUID = nil
      @LOG_FACILITY = nil
      @URL_TLD = nil
      @FQDN = nil
    end

    # Return true if the current executing user is root
    def is_current_user_root
      return true if %x(id -u) == "0"
    end

    # Return true if the user should be running this script (root or omsagent)
    def check_user
      return true if (is_current_user_root or %x(id -un) == @AGENT_USER)
    end

    # Return variable derived from install_info.txt (like "LinuxMonitoringAgent/1.2.0-148")
    def get_user_agent
      user_agent = "LinuxMonitoringAgent/"
      if File.exist?(@install_info) and !File.zero?(@install_info)
        user_agent += File.readlines(@install_info)[0].split.first
      end
      return user_agent
    end

    # Ensure files generated by this script are owned by omsagent
    def chown_omsagent(file_list)
      if is_current_user_root
        FileUtils.chown(AGENT_USER, AGENT_GROUP, file_list)
      end
    end

    # Logging methods
    def log_info(message)
      print("info\t#{message}\n")
      #%x(logger -i -p #{@LOG_FACILITY}.info -t omsagent "#{message}")
      $log.info(message)
    end

    def log_error(message)
      print("error\t#{message}\n")
      #%x(logger -i -p #{@LOG_FACILITY}.err -t omsagent "#{message}")
      $log.error(message)
    end

    def load_config_help_remove_beginning(line_nnl)
      return line_nnl[line_nnl.index("=")+1..-1]
    end

    # Load necessary configuration values from omsadmin.conf
    def load_config
      if !File.exist?(@omsadmin_conf_path)
        log_error("Missing configuration file : #{@omsadmin_conf_path}")
        return 1
      end

      File.open(@omsadmin_conf_path, "r") do |f|
        f.each_line do |line|
          if line.end_with?("\n")
            line_nnl = line[0..-2]  # no newline
          else
            line_nnl = line
          end

          # Extract variables
          if line_nnl.start_with?("WORKSPACE_ID")
            @WORKSPACE_ID = load_config_help_remove_beginning(line_nnl)
          elsif line_nnl.start_with?("AGENT_GUID")
            @AGENT_GUID = load_config_help_remove_beginning(line_nnl)
          elsif line_nnl.start_with?("LOG_FACILITY")
            @LOG_FACILITY = load_config_help_remove_beginning(line_nnl)
          elsif line_nnl.start_with?("URL_TLD")
            # Ensure URL_TLD is backwards-compatible
            if not line_nnl.end_with?(".com")
              line_nnl += ".com"
            end
            @URL_TLD = load_config_help_remove_beginning(line_nnl)
          elsif line_nnl.start_with?("FQDN")
            @FQDN = load_config_help_remove_beginning(line_nnl)
          end
        end
      end

      # Check that all necessary values have been set
      if @WORKSPACE_ID.nil? or @AGENT_GUID.nil? or @LOG_FACILITY.nil? or @URL_TLD.nil? or @FQDN.nil?
        log_error("Missing required field from configuration file: #{@omsadmin_conf_path}")
        return 1
      end

      return 0
    end

    # Extract proxy setting information from proxy configuration file
    def get_proxy_info
      require_relative 'oms_configuration'
      proxy = {}

      if File.exist?(@proxy_path) and !File.zero?(@proxy_path)
        proxy = OMS::Configuration.get_proxy_config(@proxy_path)
        log_info("Using proxy settings from #{@proxy_path}")
      end

      return proxy
    end

    # Updates the DSC_ENDPOINT variable in omsadmin.conf from the server XML
    def apply_dsc_endpoint(xml_file)
      # TODO
#        # Extract the DSC endpoint from the server response
#        DSC_CONF=`grep -o "<DscConfiguration.*DscConfiguration>" $xml_file`
#        DSC_ENDPOINT=`echo $DSC_CONF | grep -o "<Endpoint>.*</Endpoint>" | sed -e "s/<.\?Endpoint>//g" -e "s/(/\\\\\(/g" -e "s/)/\\\\\)/g"`
#
#        if [ -z "$DSC_ENDPOINT" ]; then
#            log_error "Could not extract the DSC endpoint."
#            return 1
#        fi
    end


    def heartbeat
      require_relative 'agent_topology_request_script'
      loaded = load_config
      if loaded != 0
        return 1
      end

      # Generate the request body
      cert_server = ""
      cert_file_contents = File.readlines(@cert_path)
      for i in 1..(cert_file_contents.length-2) #skip first and last line in file
        line = cert_file_contents[i]
        cert_server += line[0..-2]
        if i < (cert_file_contents.length-2)
          cert_server += " "
        end
      end

      begin
        body_hb_xml = AgentTopologyRequestHandler.new.handle_request(@os_info, @omsadmin_conf_path,
            @FQDN, @AGENT_GUID, cert_server, telemetry=true)
      rescue => e
        log_error("Error when appending Telemetry to Heartbeat")
      end

      # Form POST request with headers
      headers = {}
      req_date = Time.now.utc.strftime("%Y-%m-%dT%T.%N%:z")
      headers[OMS::CaseSensitiveString.new("x-ms-Date")] = req_date
      # Invalid header 400 is returned when this is included
#      headers[OMS::CaseSensitiveString.new("User-Agent")] = get_user_agent
      headers[OMS::CaseSensitiveString.new("Accept-Language")] = "en-US"
      uri = URI.parse("https://#{@WORKSPACE_ID}.oms.#{@URL_TLD}/AgentService.svc/LinuxAgentTopologyRequest")
      req = Net::HTTP::Post.new(uri.request_uri, headers)
      req.body = body_hb_xml

      # Form HTTP
      http = OMS::Common.create_secure_http(uri, get_proxy_info)
      if File.exist?(@cert_path) and File.exist?(@key_path)
        http.cert = OpenSSL::X509::Certificate.new(File.open(@cert_path))
        http.key = OpenSSL::PKey::RSA.new(File.open(@key_path))
      else
        log_error("Certificates for heartbeat request do not exist")
        return 1
      end

      # Submit request
      begin
        res = nil
        res = http.start { |http_each| http.request(req) }
      rescue
        log_error("Error sending the heartbeat.")
      end

      if !res.nil?
        if res.code == "200"
       # TODO
#        apply_certificate_update_endpoint $RESP_HEARTBEAT
#        apply_dsc_endpoint $RESP_HEARTBEAT
#        log_info "Heartbeat success"
#
#        # Save the current certificate endpoint url
#        save_config
#
        else
          log_error("Error sending the heartbeat. HTTP code #{res.code}")
          return 1
        end
      else
        log_error("Error sending the heartbeat. No HTTP code")
        return 1
      end

      return 0
    end

  
    def generate_certs
      log_info("Generating certificate ...")
      error=nil

      # Set safe certificate permissions before to prevent timing attacks
      key_file = File.new(@key_path, "w")
      cert_file = File.new(@cert_path, "w")
      File.chmod(0600, [@key_path, @cert_path])
      chown_omsagent([@key_path, @cert_path])

      begin
        # Create new private key of 2048 bits
        key = OpenSSL::PKey::RSA.new(2048)
  
        # Generate CSR from new private key
        csr = OpenSSL::X509::Request.new
        csr.subject = OpenSSL::X509::Name.parse("/CN=$WORKSPACE_ID/CN=$AGENT_GUID/OU=Linux Monitoring Agent/O=Microsoft")
        csr.public_key = key.public_key
        csr.sign(key, OpenSSL::Digest::SHA256.new)
  
        # Self-sign CSR
        csr_cert = OpenSSL::X509::Certificate.new
        csr_cert.not_before = Time.now
        csr_cert.not_after = Time.now + 1 * 365 * 24 * 60 * 60 # 365 days
        csr_cert.subject = csr.subject
        csr_cert.public_key = csr.public_key
        csr_cert.issuer = csr_cert.subject  # self-signed
        csr_cert.sign(key, OpenSSL::Digest::SHA256.new)

        # Write key and cert to files
        key_file.write(key)
        cert_file.write(csr_cert)
      rescue => e
        error = e
      ensure
        key_file.close
        cert_file.close
      end

      # Check for any error or non-existent or empty files
      if error.nil? or !File.exist?(key_file) or !File.exist?(cert_file) or 
          File.zero?(key_file) or File.zero?(cert_file)
        log_error("Error generating certs")
        return 1
      end

      return 0
    end
  
    def renew_cert
      generate_certs
    end

    # Dummy method for FluentD's benefit; the output of this input plugin won't be used
    def enumerate(time)
      heartbeat
      dummy_data_item = {
        "Timestamp"=>OMS::Common.format_time(time)
      }
      wrapper = {
        "DataType"=>"dummyDataType",
        "IPName"=>"dummyIPName",
        "DataItems"=>[dummy_data_item]
      }
      return wrapper
    end

  end # class Maintenance
end # module MaintenanceModule


if __FILE__ == $0
  options = {}
  OptionParser.new do |opts|
    opts.on("-h", "--heartbeat") do |h|
      options[:heartbeat] = h
    end
    opts.on("-c", "--certificates") do |c|
      options[:generate_certs] = c
    end
    opts.on("-d", "--dsc XML") do |d|
      options[:apply_dsc_endpoint] = d
    end
  end.parse!

  omsadmin_conf_path = ARGV[0]
  cert_path = ARGV[1]
  key_path = ARGV[2]
  proxy_path = ARGV[3]
  os_info = ARGV[4]
  install_info = ARGV[5]

  maintenance = MaintenanceModule::Maintenance.new(omsadmin_conf_path, cert_path, key_path, proxy_path, os_info, install_info)
  ret_code = 0

  if !maintenance.check_user
    maintenance.log_error("This script must be run as root or as the #{maintenance.AGENT_USER} user.")
    ret_code = 1
  elsif options[:heartbeat]
    ret_code = maintenance.heartbeat
  elsif options[:generate_certs]
    ret_code = maintenance.generate_certs
  elsif options[:apply_dsc_endpoint]
    ret_code = maintenance.apply_dsc_endpoint(options[:apply_dsc_endpoint])
  end

  exit ret_code
end
