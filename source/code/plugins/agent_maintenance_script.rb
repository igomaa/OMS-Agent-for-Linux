require 'openssl'
require 'fileutils'
require 'net/http'
require 'uri'
require 'optparse'

module MaintenanceModule

  class Maintenance
    require_relative 'oms_common'

    # Constants
    attr_reader :AGENT_USER, :string
    attr_reader :AGENT_GROUP, :string
    # Passed in parameters
    attr_reader :omsadmin_conf_path
    attr_reader :cert_path
    attr_reader :key_path
    attr_reader :proxy_path
    attr_reader :os_info
    attr_reader :install_info
  
    def initialize(omsadmin_conf_path, cert_path, key_path, proxy_path, os_info, install_info)
      @AGENT_USER = "omsagent"
      @AGENT_GROUP = "omiusers"
      @omsadmin_conf_path = omsadmin_conf_path
      @cert_path = cert_path
      @key_path = key_path
      @proxy_path = proxy_path
      @os_info = os_info
      @install_info = install_info
      # Config to be read/written from omsadmin.conf
      @WORKSPACE_ID = nil
      @AGENT_GUID = nil
      @URL_TLD = nil
      @FQDN = nil
    end

    # Return true if the current executing user is root
    def is_current_user_root
      return true if (%x(id -u)).strip == "0"
    end

    # Return true if the user should be running this script (root or omsagent)
    def check_user
      return true if (is_current_user_root or (%x(id -un)).strip == @AGENT_USER)
    end

    # Return variable derived from install_info.txt (like "LinuxMonitoringAgent/1.2.0-148")
    def get_user_agent
      user_agent = "LinuxMonitoringAgent/"
      if File.exist?(@install_info) and !File.zero?(@install_info)
        user_agent += File.readlines(@install_info)[0].split.first
      end
      return user_agent
    end

    # Ensure files generated by this script are owned by omsagent
    def chown_omsagent(file_list)
      if is_current_user_root
        FileUtils.chown(@AGENT_USER, @AGENT_GROUP, file_list)
      end
    end

    # Logging methods
    def log_info(message)
      print("info\t#{message}\n")
      if !$log.nil?
        $log.info(message)
      else
        %x(logger -i -p local0.info -t omsagent "#{message}")
      end
    end

    def log_error(message)
      print("error\t#{message}\n")
      if !$log.nil?
        $log.error(message)
      else
        %x(logger -i -p local0.error -t omsagent "#{message}")
      end
    end

    def load_config_help_remove_beginning(line_nnl)
      return line_nnl[line_nnl.index("=")+1..-1]
    end

    # Load necessary configuration values from omsadmin.conf
    def load_config
      if !File.exist?(@omsadmin_conf_path)
        log_error("Missing configuration file : #{@omsadmin_conf_path}")
        return 1
      end

      File.open(@omsadmin_conf_path, "r") do |f|
        f.each_line do |line|
          if line.end_with?("\n")
            line_nnl = line[0..-2]  # no newline
          else
            line_nnl = line
          end

          # Extract variables
          if line_nnl.start_with?("WORKSPACE_ID")
            @WORKSPACE_ID = load_config_help_remove_beginning(line_nnl)
          elsif line_nnl.start_with?("AGENT_GUID")
            @AGENT_GUID = load_config_help_remove_beginning(line_nnl)
          elsif line_nnl.start_with?("URL_TLD")
            # Ensure URL_TLD is backwards-compatible
            if not line_nnl.end_with?(".com")
              line_nnl += ".com"
            end
            @URL_TLD = load_config_help_remove_beginning(line_nnl)
          elsif line_nnl.start_with?("FQDN")
            @FQDN = load_config_help_remove_beginning(line_nnl)
          end
        end
      end

      # Check that all necessary values have been set
      if @WORKSPACE_ID.nil? or @AGENT_GUID.nil? or @URL_TLD.nil? or @FQDN.nil?
        log_error("Missing required field from configuration file: #{@omsadmin_conf_path}")
        return 1
      end

      return 0
    end

    # Update omsadmin.conf with the specified variable's value
    def update_config(var, val)
      if !File.exist?(@omsadmin_conf_path)
        log_error("Missing configuration file : #{@omsadmin_conf_path}")
        return 1
      end

      old_text = File.read(@omsadmin_conf_path)
      new_text = old_text.sub(/#{var}=.*\n/,"#{var}=#{val}\n")

      File.open(@omsadmin_conf_path, "w") { |file|
        file.puts(new_text)
      }
    end

    # Extract proxy setting information from proxy configuration file
    def get_proxy_info
      require_relative 'oms_configuration'
      proxy = {}

      if File.exist?(@proxy_path) and !File.zero?(@proxy_path)
        proxy = OMS::Configuration.get_proxy_config(@proxy_path)
        log_info("Using proxy settings from #{@proxy_path}")
      end

      return proxy
    end


    # Updates the CERTIFICATE_UPDATE_ENDPOINT variable and renews certificate if requested
    def apply_certificate_update_endpoint(server_resp)
      update_attr = ""
      cert_update_endpoint = ""

      # Extract the certificate update endpoint from the server response
      endpoint_tag_regex = /\<CertificateUpdateEndpoint.*updateCertificate=\"(?<update_cert>(true|false))\".*(?<cert_update_endpoint>https.*RenewCertificate).*CertificateUpdateEndpoint\>/
      endpoint_tag_regex.match(server_resp) { |match|
        cert_update_endpoint = match['cert_update_endpoint']
        update_attr = match['update_cert']
      }
 
      if cert_update_endpoint.empty?
        log_error("Could not extract the update certificate endpoint.")
        return 1
      elsif update_attr.empty?
        log_error("Could not find the updateCertificate tag in the heartbeat response")
        return 1
      end

      # Update omsadmin.conf with cert_update_endpoint variable
      update_config("CERTIFICATE_UPDATE_ENDPOINT", cert_update_endpoint)
 
      # Check in the response if the certs should be renewed
      if update_attr == "true"
        renew_cert
      end

      return 0
    end

    # Update the DSC_ENDPOINT variable in omsadmin.conf from the server XML
    def apply_dsc_endpoint(server_resp)
      dsc_endpoint = ""

      # Extract the DSC endpoint from the server response
      dsc_conf_regex = /<DscConfiguration.*<Endpoint>(?<endpoint>.*)<\/Endpoint>.*DscConfiguration>/
      dsc_conf_regex.match(server_resp) { |match|
        dsc_endpoint = match['endpoint']
        # Insert escape characters before open and closed parentheses
        dsc_endpoint = dsc_endpoint.gsub("(", "\\\\(").gsub(")", "\\\\)")
      }

      if dsc_endpoint.empty?
        log_error("Could not extract the DSC endpoint.")
        return 1
      end

      # Update omsadmin.conf with dsc_endpoint variable
      update_config("DSC_ENDPOINT", dsc_endpoint)

      return 0
    end

    # Pass the data from an XML file to apply_dsc_endpoint
    def apply_dsc_endpoint_file(xml_file)
      if !File.exist?(xml_file)
        return 1
      else
        return apply_dsc_endpoint(File.read(xml_file))
      end
    end


    def heartbeat
      require_relative 'agent_topology_request_script'
      loaded = load_config
      if loaded != 0
        return 1
      end

      # Generate the request body
      cert_server = ""
      cert_file_contents = File.readlines(@cert_path)
      for i in 1..(cert_file_contents.length-2) #skip first and last line in file
        line = cert_file_contents[i]
        cert_server += line[0..-2]
        if i < (cert_file_contents.length-2)
          cert_server += " "
        end
      end

      begin
        body_hb_xml = AgentTopologyRequestHandler.new.handle_request(@os_info, @omsadmin_conf_path,
            @FQDN, @AGENT_GUID, cert_server, telemetry=true)
      rescue => e
        log_error("Error when appending Telemetry to Heartbeat")
      end

      # Form POST request with headers
      headers = {}
      req_date = Time.now.utc.strftime("%Y-%m-%dT%T.%N%:z")
      headers[OMS::CaseSensitiveString.new("x-ms-Date")] = req_date
      # Invalid header 400 is returned when this is included
#      headers[OMS::CaseSensitiveString.new("User-Agent")] = get_user_agent
      headers[OMS::CaseSensitiveString.new("Accept-Language")] = "en-US"
      uri = URI.parse("https://#{@WORKSPACE_ID}.oms.#{@URL_TLD}/AgentService.svc/LinuxAgentTopologyRequest")
      req = Net::HTTP::Post.new(uri.request_uri, headers)
      req.body = body_hb_xml

      # Form HTTP
      http = OMS::Common.create_secure_http(uri, get_proxy_info)
      if File.exist?(@cert_path) and File.exist?(@key_path)
        http.cert = OpenSSL::X509::Certificate.new(File.open(@cert_path))
        http.key = OpenSSL::PKey::RSA.new(File.open(@key_path))
      else
        log_error("Certificates for heartbeat request do not exist")
        return 1
      end

      # Submit request
      begin
        res = nil
        res = http.start { |http_each| http.request(req) }
      rescue
        log_error("Error sending the heartbeat.")
      end

      if !res.nil?
        if res.code == "200"
          results = 0
          results = 1 if apply_certificate_update_endpoint(res.body) != 0
          results = 1 if apply_dsc_endpoint(res.body) != 0

          log_info("Heartbeat success") if results == 0
          return results
        else
          log_error("Error sending the heartbeat. HTTP code #{res.code}")
          return 1
        end
      else
        log_error("Error sending the heartbeat. No HTTP code")
        return 1
      end
    end

  
    def generate_certs(workspace_id, agent_guid)
      if workspace_id.nil? or agent_guid.nil?
        log_error("Both WORKSPACE_ID and AGENT_GUID must be defined to generate certificates")
        return 1
      end
      log_info("Generating certificate ...")
      error=nil

      # Set safe certificate permissions before to prevent timing attacks
      key_file = File.new(@key_path, "w")
      cert_file = File.new(@cert_path, "w")
      File.chmod(0600, @key_path)
      File.chmod(0600, @cert_path)
      chown_omsagent([@key_path, @cert_path])

      begin
        # Create new private key of 2048 bits
        key = OpenSSL::PKey::RSA.new(2048)
  
        # Generate CSR from new private key
        csr = OpenSSL::X509::Request.new
        csr.subject = OpenSSL::X509::Name.parse("/CN=#{workspace_id}/CN=#{agent_guid}/OU=Linux Monitoring Agent/O=Microsoft")
        csr.public_key = key.public_key
        csr.sign(key, OpenSSL::Digest::SHA256.new)
  
        # Self-sign CSR
        csr_cert = OpenSSL::X509::Certificate.new
        csr_cert.not_before = Time.now
        csr_cert.not_after = Time.now + 1 * 365 * 24 * 60 * 60 # 365 days
        csr_cert.subject = csr.subject
        csr_cert.public_key = csr.public_key
        csr_cert.issuer = csr_cert.subject  # self-signed
        csr_cert.sign(key, OpenSSL::Digest::SHA256.new)

        # Write key and cert to files
        key_file.write(key)
        cert_file.write(csr_cert)
      rescue => e
        error = e
      ensure
        key_file.close
        cert_file.close
      end

      # Check for any error or non-existent or empty files
      if !error.nil? or !File.exist?(@key_path) or !File.exist?(@cert_path) or 
          File.zero?(@key_path) or File.zero?(@cert_path)
        log_error("Error generating certs")
        return 1
      end

      return 0
    end
  
    def renew_cert

      #TODO
      generate_certs(@WORKSPACE_ID, @AGENT_GUID)

      return 0
    end

  end # class Maintenance
end # module MaintenanceModule


if __FILE__ == $0
  options = {}
  OptionParser.new do |opts|
    opts.on("-h", "--heartbeat") do |h|
      options[:heartbeat] = h
    end
    opts.on("-c", "--certificates") do |c|
      options[:generate_certs] = c
    end
    opts.on("-w WORKSPACE_ID") do |w|
      options[:workspace_id] = w
    end
    opts.on("-a AGENT_GUID") do |a|
      options[:agent_guid] = a
    end
    opts.on("-d", "--dsc XML") do |d|
      options[:apply_dsc_endpoint] = d
    end
  end.parse!

  omsadmin_conf_path = ARGV[0]
  cert_path = ARGV[1]
  key_path = ARGV[2]
  proxy_path = ARGV[3]
  os_info = ARGV[4]
  install_info = ARGV[5]

  maintenance = MaintenanceModule::Maintenance.new(omsadmin_conf_path, cert_path, key_path, proxy_path, os_info, install_info)
  ret_code = 0

  if !maintenance.check_user
    maintenance.log_error("This script must be run as root or as the #{maintenance.AGENT_USER} user.")
    ret_code = 1
  elsif options[:heartbeat]
    ret_code = maintenance.heartbeat
  elsif options[:generate_certs]
    if options[:workspace_id].nil? or options[:agent_guid].nil?
      maintenance.log_error("To generate certificates, you must include both -w WORKSPACE_ID and -a AGENT_GUID")
      ret_code = 1
    else
      ret_code = maintenance.generate_certs(options[:workspace_id], options[:agent_guid])
    end
  elsif options[:apply_dsc_endpoint]
    ret_code = maintenance.apply_dsc_endpoint_file(options[:apply_dsc_endpoint])
  end

  exit ret_code
end
